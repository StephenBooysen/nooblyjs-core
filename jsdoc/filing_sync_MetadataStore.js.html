<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: filing/sync/MetadataStore.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: filing/sync/MetadataStore.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * @fileoverview Metadata Store for sync filing provider
 * Tracks file states, locks, and synchronization information
 * @author NooblyJS Team
 * @version 1.0.15
 */

'use strict';

const fs = require('fs').promises;
const path = require('path');

/**
 * File states in the sync system
 */
const FileStates = {
  DRAFT: 'draft',           // Local only, never synced
  CLEAN: 'clean',           // In sync with remote
  MODIFIED: 'modified',     // Local changes, needs push
  LOCKED_LOCAL: 'locked-local',   // Locked by this user
  LOCKED_REMOTE: 'locked-remote', // Locked by another user
  CONFLICT: 'conflict'      // Both local and remote changed
};

/**
 * Metadata store for managing file sync information
 */
class MetadataStore {
  /**
   * Creates a new MetadataStore instance
   * @param {string} metadataDir - Directory to store metadata
   * @param {string} userId - Current user ID
   * @param {EventEmitter} eventEmitter - Event emitter for notifications
   */
  constructor(metadataDir = './.sync', userId = 'default-user', eventEmitter) {
    this.metadataDir = path.resolve(metadataDir);
    this.metadataFile = path.join(this.metadataDir, 'metadata.json');
    this.userId = userId;
    this.eventEmitter_ = eventEmitter;
    this.metadata = new Map();
    this._initialized = false;
  }

  /**
   * Initializes the metadata store
   * @returns {Promise&lt;void>}
   */
  async initialize() {
    if (this._initialized) return;

    await fs.mkdir(this.metadataDir, { recursive: true });
    await this._loadMetadata();
    this._initialized = true;
  }

  /**
   * Loads metadata from disk
   * @private
   */
  async _loadMetadata() {
    try {
      const data = await fs.readFile(this.metadataFile, 'utf8');
      const metadata = JSON.parse(data);
      this.metadata = new Map(Object.entries(metadata));
    } catch (error) {
      if (error.code !== 'ENOENT') {
        throw new Error(`Failed to load metadata: ${error.message}`);
      }
      // File doesn't exist yet, start with empty metadata
      this.metadata = new Map();
    }
  }

  /**
   * Saves metadata to disk
   * @private
   */
  async _saveMetadata() {
    const data = Object.fromEntries(this.metadata);
    await fs.writeFile(this.metadataFile, JSON.stringify(data, null, 2));
  }

  /**
   * Gets file metadata
   * @param {string} filePath - File path
   * @returns {Object|null} File metadata or null if not found
   */
  getFileMetadata(filePath) {
    return this.metadata.get(filePath) || null;
  }

  /**
   * Sets file metadata
   * @param {string} filePath - File path
   * @param {Object} metadata - File metadata
   * @returns {Promise&lt;void>}
   */
  async setFileMetadata(filePath, metadata) {
    const currentMeta = this.getFileMetadata(filePath) || {};
    const newMeta = {
      ...currentMeta,
      ...metadata,
      lastModified: new Date().toISOString()
    };
    
    this.metadata.set(filePath, newMeta);
    await this._saveMetadata();
    
    this.eventEmitter_?.emit('metadata:updated', { path: filePath, metadata: newMeta });
  }

  /**
   * Gets file state
   * @param {string} filePath - File path
   * @returns {string} File state
   */
  getFileState(filePath) {
    const metadata = this.getFileMetadata(filePath);
    return metadata?.state || FileStates.DRAFT;
  }

  /**
   * Sets file state
   * @param {string} filePath - File path
   * @param {string} state - File state
   * @returns {Promise&lt;void>}
   */
  async setFileState(filePath, state) {
    await this.setFileMetadata(filePath, { state });
    this.eventEmitter_?.emit('file:state:changed', { path: filePath, state });
  }

  /**
   * Checks if file is locked
   * @param {string} filePath - File path
   * @returns {Object|null} Lock information or null if not locked
   */
  getFileLock(filePath) {
    const metadata = this.getFileMetadata(filePath);
    return metadata?.lock || null;
  }

  /**
   * Locks a file
   * @param {string} filePath - File path
   * @param {string} [userId] - User ID (defaults to current user)
   * @param {string} [reason] - Lock reason
   * @returns {Promise&lt;void>}
   */
  async lockFile(filePath, userId = this.userId, reason = 'Editing') {
    const lockInfo = {
      userId,
      reason,
      timestamp: new Date().toISOString()
    };

    await this.setFileMetadata(filePath, { 
      lock: lockInfo,
      state: userId === this.userId ? FileStates.LOCKED_LOCAL : FileStates.LOCKED_REMOTE
    });
    
    this.eventEmitter_?.emit('file:locked', { path: filePath, lock: lockInfo });
  }

  /**
   * Unlocks a file
   * @param {string} filePath - File path
   * @param {string} [userId] - User ID (defaults to current user)
   * @returns {Promise&lt;void>}
   */
  async unlockFile(filePath, userId = this.userId) {
    const lock = this.getFileLock(filePath);
    
    if (!lock) {
      throw new Error(`File is not locked: ${filePath}`);
    }

    if (lock.userId !== userId &amp;&amp; userId === this.userId) {
      throw new Error(`Cannot unlock file locked by another user: ${filePath}`);
    }

    await this.setFileMetadata(filePath, { 
      lock: null,
      state: FileStates.CLEAN // Reset to clean state after unlock
    });
    
    this.eventEmitter_?.emit('file:unlocked', { path: filePath, previousLock: lock });
  }

  /**
   * Checks if file is locked by current user
   * @param {string} filePath - File path
   * @returns {boolean} True if locked by current user
   */
  isLockedByCurrentUser(filePath) {
    const lock = this.getFileLock(filePath);
    return lock &amp;&amp; lock.userId === this.userId;
  }

  /**
   * Checks if file is locked by another user
   * @param {string} filePath - File path
   * @returns {boolean} True if locked by another user
   */
  isLockedByOtherUser(filePath) {
    const lock = this.getFileLock(filePath);
    return lock &amp;&amp; lock.userId !== this.userId;
  }

  /**
   * Gets files in a specific state
   * @param {string} state - File state to filter by
   * @returns {Array&lt;string>} Array of file paths in the specified state
   */
  getFilesByState(state) {
    const files = [];
    for (const [filePath, metadata] of this.metadata) {
      if (metadata.state === state) {
        files.push(filePath);
      }
    }
    return files;
  }

  /**
   * Gets all locked files
   * @returns {Array&lt;Object>} Array of locked file information
   */
  getLockedFiles() {
    const lockedFiles = [];
    for (const [filePath, metadata] of this.metadata) {
      if (metadata.lock) {
        lockedFiles.push({
          path: filePath,
          lock: metadata.lock,
          state: metadata.state
        });
      }
    }
    return lockedFiles;
  }

  /**
   * Sets remote sync timestamp for a file
   * @param {string} filePath - File path
   * @param {string} timestamp - Remote timestamp
   * @returns {Promise&lt;void>}
   */
  async setRemoteTimestamp(filePath, timestamp) {
    await this.setFileMetadata(filePath, { remoteTimestamp: timestamp });
  }

  /**
   * Gets remote sync timestamp for a file
   * @param {string} filePath - File path
   * @returns {string|null} Remote timestamp or null
   */
  getRemoteTimestamp(filePath) {
    const metadata = this.getFileMetadata(filePath);
    return metadata?.remoteTimestamp || null;
  }

  /**
   * Removes file from metadata
   * @param {string} filePath - File path
   * @returns {Promise&lt;void>}
   */
  async removeFile(filePath) {
    this.metadata.delete(filePath);
    await this._saveMetadata();
    
    this.eventEmitter_?.emit('metadata:removed', { path: filePath });
  }

  /**
   * Gets sync status for all files
   * @returns {Object} Sync status summary
   */
  getSyncStatus() {
    const status = {
      draft: [],
      clean: [],
      modified: [],
      lockedLocal: [],
      lockedRemote: [],
      conflict: [],
      total: this.metadata.size
    };

    for (const [filePath, metadata] of this.metadata) {
      const state = metadata.state || FileStates.DRAFT;
      switch (state) {
        case FileStates.DRAFT:
          status.draft.push(filePath);
          break;
        case FileStates.CLEAN:
          status.clean.push(filePath);
          break;
        case FileStates.MODIFIED:
          status.modified.push(filePath);
          break;
        case FileStates.LOCKED_LOCAL:
          status.lockedLocal.push(filePath);
          break;
        case FileStates.LOCKED_REMOTE:
          status.lockedRemote.push(filePath);
          break;
        case FileStates.CONFLICT:
          status.conflict.push(filePath);
          break;
      }
    }

    return status;
  }
}

module.exports = { MetadataStore, FileStates };</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-CachingViews.html">CachingViews</a></li><li><a href="module-DataserveViews.html">DataserveViews</a></li><li><a href="module-FilingViews.html">FilingViews</a></li><li><a href="module-LoggingViews.html">LoggingViews</a></li><li><a href="module-MeasuringViews.html">MeasuringViews</a></li><li><a href="module-NotifyingViews.html">NotifyingViews</a></li><li><a href="module-QueueingViews.html">QueueingViews</a></li><li><a href="module-SchedulingViews.html">SchedulingViews</a></li><li><a href="module-SearchingViews.html">SearchingViews</a></li><li><a href="module-WorkflowViews.html">WorkflowViews</a></li><li><a href="module-WorkingViews.html">WorkingViews</a></li></ul><h3>Classes</h3><ul><li><a href="Cache.html">Cache</a></li><li><a href="CacheFile.html">CacheFile</a></li><li><a href="CacheMemcached.html">CacheMemcached</a></li><li><a href="CacheRedis.html">CacheRedis</a></li><li><a href="CommitQueue.html">CommitQueue</a></li><li><a href="DocumentDBDataServeProvider.html">DocumentDBDataServeProvider</a></li><li><a href="FileDataRingProvider.html">FileDataRingProvider</a></li><li><a href="FilingService.html">FilingService</a></li><li><a href="FtpFilingProvider.html">FtpFilingProvider</a></li><li><a href="GCPFilingProvider.html">GCPFilingProvider</a></li><li><a href="GitFilingProvider.html">GitFilingProvider</a></li><li><a href="InMemoryDataServeProvider.html">InMemoryDataServeProvider</a></li><li><a href="InMemoryQueue.html">InMemoryQueue</a></li><li><a href="LocalFilingProvider.html">LocalFilingProvider</a></li><li><a href="LocalWorkingStore.html">LocalWorkingStore</a></li><li><a href="MeasuringService.html">MeasuringService</a></li><li><a href="MetadataStore.html">MetadataStore</a></li><li><a href="MongoDBDataServeProvider.html">MongoDBDataServeProvider</a></li><li><a href="NotificationService.html">NotificationService</a></li><li><a href="S3FilingProvider.html">S3FilingProvider</a></li><li><a href="SchedulerProvider.html">SchedulerProvider</a></li><li><a href="SearchService.html">SearchService</a></li><li><a href="SimpleDbDataRingProvider.html">SimpleDbDataRingProvider</a></li><li><a href="SyncFilingProvider.html">SyncFilingProvider</a></li><li><a href="WorkerProvider.html">WorkerProvider</a></li><li><a href="WorkflowService.html">WorkflowService</a></li><li><a href="logging.html">logging</a></li><li><a href="loggingFile.html">loggingFile</a></li></ul><h3>Global</h3><ul><li><a href="global.html#FileStates">FileStates</a></li><li><a href="global.html#createApiKeyAuthMiddleware">createApiKeyAuthMiddleware</a></li><li><a href="global.html#createCache">createCache</a></li><li><a href="global.html#createDataserveService">createDataserveService</a></li><li><a href="global.html#createFilingService">createFilingService</a></li><li><a href="global.html#createLogger">createLogger</a></li><li><a href="global.html#createMeasuringService">createMeasuringService</a></li><li><a href="global.html#createNotificationService">createNotificationService</a></li><li><a href="global.html#createQueue">createQueue</a></li><li><a href="global.html#createSearchService">createSearchService</a></li><li><a href="global.html#createWorkflowService">createWorkflowService</a></li><li><a href="global.html#generateApiKey">generateApiKey</a></li><li><a href="global.html#getNestedValue">getNestedValue</a></li><li><a href="global.html#getSchedulerInstance">getSchedulerInstance</a></li><li><a href="global.html#getWorkerInstance">getWorkerInstance</a></li><li><a href="global.html#instance">instance</a></li><li><a href="global.html#isValidApiKeyFormat">isValidApiKeyFormat</a></li><li><a href="global.html#runStep">runStep</a></li><li><a href="global.html#status">status</a></li><li><a href="global.html#updateStatus">updateStatus</a></li><li><a href="global.html#userScript">userScript</a></li><li><a href="global.html#userScriptPath">userScriptPath</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.4</a> on Tue Sep 02 2025 12:14:25 GMT+0000 (Coordinated Universal Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
