<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: dataserve/providers/dataserveDocumentDB.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: dataserve/providers/dataserveDocumentDB.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * @fileoverview DocumentDB DataServe provider for storing and searching JSON objects
 * with container-based organization using DocumentDB collections and event emission support.
 * Compatible with MongoDB-compatible DocumentDB implementations.
 * @author NooblyJS Team
 * @version 1.0.14
 * @since 1.0.0
 */

'use strict';

const { MongoClient } = require('mongodb');
const { v4: uuidv4 } = require('uuid');

/**
 * A class that implements a DocumentDB data storage provider.
 * Provides methods for creating containers (collections) and storing, retrieving, and searching JSON objects.
 * Compatible with MongoDB-compatible DocumentDB implementations including open-source DocumentDB.
 * @class
 */
class DocumentDBDataServeProvider {
  /**
   * Initializes the DocumentDB data storage provider.
   * @param {Object=} options Configuration options for DocumentDB connection.
   * @param {string=} options.host DocumentDB host (defaults to '127.0.0.1').
   * @param {number=} options.port DocumentDB port (defaults to 10260).
   * @param {string=} options.database Database name to use (defaults to 'nooblyjs').
   * @param {string=} options.username Username for authentication (optional).
   * @param {string=} options.password Password for authentication (optional).
   * @param {boolean=} options.ssl Enable SSL connection (defaults to false for local development).
   * @param {string=} options.connectionString Full connection string (overrides individual options).
   * @param {EventEmitter=} eventEmitter Optional event emitter for data operations.
   */
  constructor(options = {}, eventEmitter) {
    /** @private @const {string} */
    this.host_ = options.host || '127.0.0.1';
    
    /** @private @const {number} */
    this.port_ = options.port || 10260;
    
    /** @private @const {string} */
    this.databaseName_ = options.database || 'nooblyjs';
    
    /** @private @const {string} */
    this.username_ = options.username || '';
    
    /** @private @const {string} */
    this.password_ = options.password || '';
    
    /** @private @const {boolean} */
    this.ssl_ = options.ssl || false;
    
    /** @private @const {string} */
    this.connectionString_ = this.buildConnectionString_(options);
    
    /** @private @const {EventEmitter} */
    this.eventEmitter_ = eventEmitter;
    
    /** @private @type {MongoClient|null} */
    this.client_ = null;
    
    /** @private @type {Object|null} */
    this.db_ = null;
    
    /** @private @const {Set&lt;string>} */
    this.initializedContainers_ = new Set();
    
    // Initialize connection
    this.initializeConnection_();
  }

  /**
   * Builds the DocumentDB connection string from options.
   * @param {Object} options Configuration options.
   * @return {string} DocumentDB connection string.
   * @private
   */
  buildConnectionString_(options) {
    if (options.connectionString) {
      return options.connectionString;
    }
    
    let connectionString = 'mongodb://';
    
    // Add authentication if provided
    if (this.username_ &amp;&amp; this.password_) {
      connectionString += `${encodeURIComponent(this.username_)}:${encodeURIComponent(this.password_)}@`;
    }
    
    // Add host and port
    connectionString += `${this.host_}:${this.port_}`;
    
    // Add database
    connectionString += `/${this.databaseName_}`;
    
    // Add SSL option if enabled
    const queryParams = [];
    if (this.ssl_) {
      queryParams.push('ssl=true');
    }
    
    // DocumentDB specific options for compatibility
    queryParams.push('retryWrites=false'); // DocumentDB doesn't support retryable writes
    
    if (queryParams.length > 0) {
      connectionString += '?' + queryParams.join('&amp;');
    }
    
    return connectionString;
  }

  /**
   * Initializes the DocumentDB connection.
   * @private
   */
  async initializeConnection_() {
    try {
      // DocumentDB connection options
      const clientOptions = {
        serverSelectionTimeoutMS: 5000,
        connectTimeoutMS: 5000,
        // DocumentDB specific options
        retryWrites: false,
        readPreference: 'primary'
      };
      
      this.client_ = new MongoClient(this.connectionString_, clientOptions);
      await this.client_.connect();
      this.db_ = this.client_.db(this.databaseName_);
      
      if (this.eventEmitter_) {
        this.eventEmitter_.emit('dataserve:documentdb:connected', {
          host: this.host_,
          port: this.port_,
          database: this.databaseName_,
          ssl: this.ssl_
        });
      }
    } catch (error) {
      if (this.eventEmitter_) {
        this.eventEmitter_.emit('dataserve:documentdb:error', {
          operation: 'connect',
          error: error.message
        });
      }
      throw new Error(`DocumentDB connection failed: ${error.message}`);
    }
  }

  /**
   * Ensures DocumentDB connection is established.
   * @private
   */
  async ensureConnection_() {
    if (!this.client_ || !this.db_) {
      await this.initializeConnection_();
    }
  }

  /**
   * Gets a DocumentDB collection (container).
   * @param {string} containerName The name of the container/collection.
   * @return {Object} DocumentDB collection object.
   * @private
   */
  getCollection_(containerName) {
    return this.db_.collection(containerName);
  }

  /**
   * Creates a new container (DocumentDB collection) for storing JSON objects.
   * @param {string} containerName The name of the container to create.
   * @return {Promise&lt;void>} A promise that resolves when the container is created.
   */
  async createContainer(containerName) {
    await this.ensureConnection_();
    
    try {
      // DocumentDB creates collections implicitly, but we can explicitly create them if needed
      if (!this.initializedContainers_.has(containerName)) {
        const collection = this.getCollection_(containerName);
        
        // Create an index on the uuid field for better performance
        // Note: DocumentDB has some limitations on index creation
        try {
          await collection.createIndex({ uuid: 1 }, { unique: true });
        } catch (indexError) {
          // DocumentDB might not support unique indexes in all configurations
          console.warn(`DocumentDB index creation warning for ${containerName}: ${indexError.message}`);
          // Create a non-unique index instead
          await collection.createIndex({ uuid: 1 });
        }
        
        this.initializedContainers_.add(containerName);
        
        if (this.eventEmitter_) {
          this.eventEmitter_.emit('dataserve:createContainer', { containerName });
        }
      }
    } catch (error) {
      if (this.eventEmitter_) {
        this.eventEmitter_.emit('dataserve:documentdb:error', {
          operation: 'createContainer',
          containerName,
          error: error.message
        });
      }
      throw new Error(`Failed to create container '${containerName}': ${error.message}`);
    }
  }

  /**
   * Adds a JSON object to the specified container (DocumentDB collection).
   * @param {string} containerName The name of the container to add the object to.
   * @param {!Object} jsonObject The JSON object to store.
   * @return {Promise&lt;string>} A promise that resolves to the unique key for the stored object.
   */
  async add(containerName, jsonObject) {
    await this.ensureConnection_();
    
    try {
      const collection = this.getCollection_(containerName);
      const objectKey = uuidv4();
      
      // Add uuid to the object for consistent retrieval
      const documentToInsert = {
        ...jsonObject,
        uuid: objectKey,
        _createdAt: new Date(),
        _updatedAt: new Date()
      };
      
      const result = await collection.insertOne(documentToInsert);
      
      if (this.eventEmitter_) {
        this.eventEmitter_.emit('dataserve:add', {
          containerName,
          objectKey,
          jsonObject: documentToInsert,
          documentdbId: result.insertedId
        });
      }
      
      return objectKey;
    } catch (error) {
      if (this.eventEmitter_) {
        this.eventEmitter_.emit('dataserve:documentdb:error', {
          operation: 'add',
          containerName,
          error: error.message
        });
      }
      throw new Error(`Failed to add object to container '${containerName}': ${error.message}`);
    }
  }

  /**
   * Gets a JSON object from the specified container by UUID.
   * @param {string} containerName The name of the container to retrieve the object from.
   * @param {string} objectKey The unique UUID of the object to retrieve.
   * @return {Promise&lt;Object|null>} A promise that resolves to the object or null if not found.
   */
  async getByUuid(containerName, objectKey) {
    await this.ensureConnection_();
    
    try {
      const collection = this.getCollection_(containerName);
      const result = await collection.findOne({ uuid: objectKey });
      
      if (result) {
        // Remove DocumentDB-specific fields from the result
        const { _id, uuid, _createdAt, _updatedAt, ...cleanObject } = result;
        
        if (this.eventEmitter_) {
          this.eventEmitter_.emit('dataserve:getByUuid', {
            containerName,
            objectKey,
            obj: cleanObject
          });
        }
        
        return cleanObject;
      }
      
      return null;
    } catch (error) {
      if (this.eventEmitter_) {
        this.eventEmitter_.emit('dataserve:documentdb:error', {
          operation: 'getByUuid',
          containerName,
          objectKey,
          error: error.message
        });
      }
      throw new Error(`Failed to retrieve object from container '${containerName}': ${error.message}`);
    }
  }

  /**
   * Removes a JSON object from the specified container.
   * @param {string} containerName The name of the container to remove the object from.
   * @param {string} objectKey The unique key of the object to remove.
   * @return {Promise&lt;boolean>} A promise that resolves to true if the object was removed, false otherwise.
   */
  async remove(containerName, objectKey) {
    await this.ensureConnection_();
    
    try {
      const collection = this.getCollection_(containerName);
      const result = await collection.deleteOne({ uuid: objectKey });
      
      const removed = result.deletedCount > 0;
      
      if (removed &amp;&amp; this.eventEmitter_) {
        this.eventEmitter_.emit('dataserve:remove', { containerName, objectKey });
      }
      
      return removed;
    } catch (error) {
      if (this.eventEmitter_) {
        this.eventEmitter_.emit('dataserve:documentdb:error', {
          operation: 'remove',
          containerName,
          objectKey,
          error: error.message
        });
      }
      throw new Error(`Failed to remove object from container '${containerName}': ${error.message}`);
    }
  }

  /**
   * Finds JSON objects in the specified container that contain the search term.
   * Uses DocumentDB-compatible queries and regex matching for comprehensive searching.
   * @param {string} containerName The name of the container to search in.
   * @param {string} searchTerm The term to search for (case-insensitive).
   * @return {Promise&lt;Array&lt;!Object>>} A promise that resolves to an array of matching objects.
   */
  async find(containerName, searchTerm) {
    await this.ensureConnection_();
    
    try {
      const collection = this.getCollection_(containerName);
      let results = [];
      
      if (!searchTerm || searchTerm.trim() === '') {
        // If no search term, return all objects
        const cursor = await collection.find({});
        const documents = await cursor.toArray();
        
        results = documents.map(doc => {
          const { _id, uuid, _createdAt, _updatedAt, ...cleanObject } = doc;
          return cleanObject;
        });
      } else {
        // Get all documents and perform client-side search for comprehensive matching
        // DocumentDB may have limitations on complex text search operations
        const cursor = await collection.find({});
        const documents = await cursor.toArray();
        
        const searchRegex = new RegExp(searchTerm, 'i');
        
        results = documents.filter(doc => {
          // Remove DocumentDB-specific fields
          const { _id, uuid, _createdAt, _updatedAt, ...cleanObject } = doc;
          
          // Recursive search function
          const searchInObject = (obj) => {
            for (const prop in obj) {
              if (Object.prototype.hasOwnProperty.call(obj, prop)) {
                const value = obj[prop];
                if (typeof value === 'string') {
                  if (searchRegex.test(value)) {
                    return true;
                  }
                } else if (typeof value === 'object' &amp;&amp; value !== null) {
                  if (searchInObject(value)) {
                    return true;
                  }
                }
              }
            }
            return false;
          };
          
          return searchInObject(cleanObject);
        }).map(doc => {
          const { _id, uuid, _createdAt, _updatedAt, ...cleanObject } = doc;
          return cleanObject;
        });
      }
      
      if (this.eventEmitter_) {
        this.eventEmitter_.emit('dataserve:find', {
          containerName,
          searchTerm,
          results
        });
      }
      
      return results;
    } catch (error) {
      if (this.eventEmitter_) {
        this.eventEmitter_.emit('dataserve:documentdb:error', {
          operation: 'find',
          containerName,
          searchTerm,
          error: error.message
        });
      }
      throw new Error(`Failed to search in container '${containerName}': ${error.message}`);
    }
  }

  /**
   * Gets all objects in a container.
   * @param {string} containerName The name of the container to list.
   * @return {Promise&lt;Array&lt;!Object>>} A promise that resolves to an array of all objects.
   */
  async listAll(containerName) {
    return this.find(containerName, '');
  }

  /**
   * Gets the count of objects in a container.
   * @param {string} containerName The name of the container to count.
   * @return {Promise&lt;number>} A promise that resolves to the count of objects.
   */
  async count(containerName) {
    await this.ensureConnection_();
    
    try {
      const collection = this.getCollection_(containerName);
      const count = await collection.countDocuments();
      
      if (this.eventEmitter_) {
        this.eventEmitter_.emit('dataserve:count', { containerName, count });
      }
      
      return count;
    } catch (error) {
      if (this.eventEmitter_) {
        this.eventEmitter_.emit('dataserve:documentdb:error', {
          operation: 'count',
          containerName,
          error: error.message
        });
      }
      throw new Error(`Failed to count objects in container '${containerName}': ${error.message}`);
    }
  }

  /**
   * Updates an existing object in the container.
   * @param {string} containerName The name of the container.
   * @param {string} objectKey The unique key of the object to update.
   * @param {!Object} jsonObject The updated JSON object.
   * @return {Promise&lt;boolean>} A promise that resolves to true if updated, false if not found.
   */
  async update(containerName, objectKey, jsonObject) {
    await this.ensureConnection_();
    
    try {
      const collection = this.getCollection_(containerName);
      const updateDoc = {
        ...jsonObject,
        uuid: objectKey,
        _updatedAt: new Date()
      };
      
      const result = await collection.updateOne(
        { uuid: objectKey },
        { $set: updateDoc }
      );
      
      const updated = result.modifiedCount > 0;
      
      if (updated &amp;&amp; this.eventEmitter_) {
        this.eventEmitter_.emit('dataserve:update', {
          containerName,
          objectKey,
          jsonObject: updateDoc
        });
      }
      
      return updated;
    } catch (error) {
      if (this.eventEmitter_) {
        this.eventEmitter_.emit('dataserve:documentdb:error', {
          operation: 'update',
          containerName,
          objectKey,
          error: error.message
        });
      }
      throw new Error(`Failed to update object in container '${containerName}': ${error.message}`);
    }
  }

  /**
   * Closes the DocumentDB connection.
   * @return {Promise&lt;void>} A promise that resolves when the connection is closed.
   */
  async close() {
    if (this.client_) {
      try {
        await this.client_.close();
        this.client_ = null;
        this.db_ = null;
        
        if (this.eventEmitter_) {
          this.eventEmitter_.emit('dataserve:documentdb:disconnected');
        }
      } catch (error) {
        if (this.eventEmitter_) {
          this.eventEmitter_.emit('dataserve:documentdb:error', {
            operation: 'close',
            error: error.message
          });
        }
        throw error;
      }
    }
  }

  /**
   * Gets the connection status.
   * @return {string} Connection status ('connected' or 'disconnected').
   */
  get status() {
    return this.client_ &amp;&amp; this.db_ ? 'connected' : 'disconnected';
  }

  /**
   * Gets connection information.
   * @return {Object} Connection information including host, port, database, and SSL status.
   */
  getConnectionInfo() {
    return {
      host: this.host_,
      port: this.port_,
      database: this.databaseName_,
      ssl: this.ssl_,
      status: this.status
    };
  }
}

module.exports = DocumentDBDataServeProvider;</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-CachingViews.html">CachingViews</a></li><li><a href="module-DataserveViews.html">DataserveViews</a></li><li><a href="module-FilingViews.html">FilingViews</a></li><li><a href="module-LoggingViews.html">LoggingViews</a></li><li><a href="module-MeasuringViews.html">MeasuringViews</a></li><li><a href="module-NotifyingViews.html">NotifyingViews</a></li><li><a href="module-QueueingViews.html">QueueingViews</a></li><li><a href="module-SchedulingViews.html">SchedulingViews</a></li><li><a href="module-SearchingViews.html">SearchingViews</a></li><li><a href="module-WorkflowViews.html">WorkflowViews</a></li><li><a href="module-WorkingViews.html">WorkingViews</a></li></ul><h3>Classes</h3><ul><li><a href="Cache.html">Cache</a></li><li><a href="CacheFile.html">CacheFile</a></li><li><a href="CacheMemcached.html">CacheMemcached</a></li><li><a href="CacheRedis.html">CacheRedis</a></li><li><a href="CommitQueue.html">CommitQueue</a></li><li><a href="DocumentDBDataServeProvider.html">DocumentDBDataServeProvider</a></li><li><a href="FileDataRingProvider.html">FileDataRingProvider</a></li><li><a href="FilingService.html">FilingService</a></li><li><a href="FtpFilingProvider.html">FtpFilingProvider</a></li><li><a href="GCPFilingProvider.html">GCPFilingProvider</a></li><li><a href="GitFilingProvider.html">GitFilingProvider</a></li><li><a href="InMemoryDataServeProvider.html">InMemoryDataServeProvider</a></li><li><a href="InMemoryQueue.html">InMemoryQueue</a></li><li><a href="LocalFilingProvider.html">LocalFilingProvider</a></li><li><a href="LocalWorkingStore.html">LocalWorkingStore</a></li><li><a href="MeasuringService.html">MeasuringService</a></li><li><a href="MetadataStore.html">MetadataStore</a></li><li><a href="MongoDBDataServeProvider.html">MongoDBDataServeProvider</a></li><li><a href="NotificationService.html">NotificationService</a></li><li><a href="S3FilingProvider.html">S3FilingProvider</a></li><li><a href="SchedulerProvider.html">SchedulerProvider</a></li><li><a href="SearchService.html">SearchService</a></li><li><a href="SimpleDbDataRingProvider.html">SimpleDbDataRingProvider</a></li><li><a href="SyncFilingProvider.html">SyncFilingProvider</a></li><li><a href="WorkerProvider.html">WorkerProvider</a></li><li><a href="WorkflowService.html">WorkflowService</a></li><li><a href="logging.html">logging</a></li><li><a href="loggingFile.html">loggingFile</a></li></ul><h3>Global</h3><ul><li><a href="global.html#FileStates">FileStates</a></li><li><a href="global.html#createApiKeyAuthMiddleware">createApiKeyAuthMiddleware</a></li><li><a href="global.html#createCache">createCache</a></li><li><a href="global.html#createDataserveService">createDataserveService</a></li><li><a href="global.html#createFilingService">createFilingService</a></li><li><a href="global.html#createLogger">createLogger</a></li><li><a href="global.html#createMeasuringService">createMeasuringService</a></li><li><a href="global.html#createNotificationService">createNotificationService</a></li><li><a href="global.html#createQueue">createQueue</a></li><li><a href="global.html#createSearchService">createSearchService</a></li><li><a href="global.html#createWorkflowService">createWorkflowService</a></li><li><a href="global.html#generateApiKey">generateApiKey</a></li><li><a href="global.html#getNestedValue">getNestedValue</a></li><li><a href="global.html#getSchedulerInstance">getSchedulerInstance</a></li><li><a href="global.html#getWorkerInstance">getWorkerInstance</a></li><li><a href="global.html#instance">instance</a></li><li><a href="global.html#isValidApiKeyFormat">isValidApiKeyFormat</a></li><li><a href="global.html#runStep">runStep</a></li><li><a href="global.html#status">status</a></li><li><a href="global.html#updateStatus">updateStatus</a></li><li><a href="global.html#userScript">userScript</a></li><li><a href="global.html#userScriptPath">userScriptPath</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.4</a> on Tue Sep 02 2025 12:14:25 GMT+0000 (Coordinated Universal Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
